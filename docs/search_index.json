[["index.html", "Pronóstico con series de tiempo: S&amp;P 500 Avance 4 1 Propuesta de trabajo 1.1 1. Descripción general 1.2 2. Justificación e importancia del análisis 1.3 3. Fuentes y permisos de uso", " Pronóstico con series de tiempo: S&amp;P 500 Avance 4 Grupo 1: Lilian Ramirez - Omar Rodriguez - Hans Silva 2025-11-03 1 Propuesta de trabajo 1.1 1. Descripción general El presente proyecto se desarrollará en el marco del curso de Analisis de Series de Tiempo, utilizando información estructurada en el tiempo proveniente del conjunto de datos S&amp;P 500 Stock Data, disponible públicamente en Kaggle y otras fuentes financieras abiertas como Yahoo Finance y Alpha Vantage API. El dataset contiene los precios diarios de apertura, cierre, máximos, mínimos y volumen de las principales empresas que conforman el índice S&amp;P 500, uno de los indicadores económicos más relevantes del mercado bursátil global. La información está disponible desde inicios del año 2000 hasta la actualidad, lo que ofrece una base temporal robusta para la modelación y pronóstico financiero. 1.2 2. Justificación e importancia del análisis El pronóstico de variables financieras como los precios de las acciones o el índice S&amp;P 500 es fundamental para la toma de decisiones estratégicas en inversión, gestión de riesgos y planificación económica. En particular, este proyecto busca modelar la evolución temporal de los precios ajustados de cierre del S&amp;P 500 con el fin de: Identificar tendencias y ciclos económicos que reflejen fases de expansión o recesión. Anticipar movimientos del mercado a corto y mediano plazo mediante modelos de series temporales. Evaluar la volatilidad y su impacto en decisiones de portafolio. Generar valor agregado para inversionistas, analistas y gestores financieros, al proveer información basada en evidencia y predicciones reproducibles. La relevancia de este tipo de pronóstico radica en su capacidad para transformar datos históricos en conocimiento predictivo, favoreciendo una toma de decisiones más informada en un entorno económico incierto. El proyecto será desarrollado en Bookdown y versionado en GitHub, utilizando herramientas TIC avanzadas para garantizar la transparencia, reproducibilidad y colaboración científica. 1.3 3. Fuentes y permisos de uso Fuente Descripción Permisos de uso Kaggle - S&amp;P 500 Stock Data Base de datos con precios históricos diarios de las 500 empresas del índice S&amp;P 500. Licencia pública de Kaggle (uso libre para fines académicos). Yahoo Finance Fuente alternativa para verificación y actualización de precios. Uso libre con fines no comerciales y educativos. Alpha Vantage API API gratuita para descarga de datos financieros y cotizaciones en tiempo real. Licencia MIT, uso permitido para proyectos educativos. Este documento constituye la propuesta inicial del proyecto de análisis y pronóstico del índice S&amp;P 500, cumpliendo con los lineamientos académicos y la rúbrica de evaluación establecida. "],["avance-2-análisis-exploratorio-temporal.html", "2 Avance 2 Análisis exploratorio temporal 2.1 1. Carga de paquetes y de datos 2.2 2. Clase e inicio/fin de la serie 2.3 3. Visualización general 2.4 4. Tendencia mediante promedios móviles 2.5 5. Análisis de estacionalidad: promedio mensual por año 2.6 6. Descomposición STL y gráfico estacional 2.7 7. Rezagos y autocorrelación 2.8 8. Conclusiones del Avance 2", " 2 Avance 2 Análisis exploratorio temporal En esta sección continuamos con el análisis inicial de la serie de tiempo, enfocándonos en: (i) tendencia (promedios móviles), (ii) rezagos (lag plots, ACF/PACF), y (iii) estacionalidad (tabla Año×Mes y descomposición STL). Usaremos el precio ajustado de cierre del índice S&amp;P 500 (^GSPC). 2.1 1. Carga de paquetes y de datos library(tidyverse) library(lubridate) library(quantmod) library(TTR) library(zoo) library(forecast) library(scales) library(ggplot2) library(forecast) # BoxCox.lambda, BoxCox, ndiffs, nsdiffs, autoplot.stl library(tseries) # adf.test, kpss.test library(urca) library(patchwork)# ur.pp # Ruta del archivo local ruta_archivo &lt;- &quot;C:/Users/omarj/OneDrive/Documents/Javeriana/Series de tiempo/bookdown/all_stocks_5yr.csv&quot; # Lectura del archivo spx &lt;- read_csv(ruta_archivo) ## Rows: 619040 Columns: 7 ## ── Column specification ─────────────────────────────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (1): Name ## dbl (5): open, high, low, close, volume ## date (1): date ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # Exploración básica glimpse(spx) ## Rows: 619,040 ## Columns: 7 ## $ date [3m[38;5;246m&lt;date&gt;[39m[23m 2013-02-08, 2013-02-11, 2013-02-12, 2013-02-13, 2013-02-14, 2013-02-15, 2013-02-19, 2… ## $ open [3m[38;5;246m&lt;dbl&gt;[39m[23m 15.07, 14.89, 14.45, 14.30, 14.94, 13.93, 14.33, 14.17, 13.62, 13.57, 13.60, 13.14, 13… ## $ high [3m[38;5;246m&lt;dbl&gt;[39m[23m 15.12, 15.01, 14.51, 14.94, 14.96, 14.61, 14.56, 14.26, 13.95, 13.60, 13.76, 13.42, 13… ## $ low [3m[38;5;246m&lt;dbl&gt;[39m[23m 14.63, 14.26, 14.10, 14.25, 13.16, 13.93, 14.08, 13.15, 12.90, 13.21, 13.00, 12.70, 13… ## $ close [3m[38;5;246m&lt;dbl&gt;[39m[23m 14.75, 14.46, 14.27, 14.66, 13.99, 14.50, 14.26, 13.33, 13.37, 13.57, 13.02, 13.26, 13… ## $ volume [3m[38;5;246m&lt;dbl&gt;[39m[23m 8407500, 8882000, 8126000, 10259500, 31879900, 15628000, 11354400, 14725200, 11922100,… ## $ Name [3m[38;5;246m&lt;chr&gt;[39m[23m &quot;AAL&quot;, &quot;AAL&quot;, &quot;AAL&quot;, &quot;AAL&quot;, &quot;AAL&quot;, &quot;AAL&quot;, &quot;AAL&quot;, &quot;AAL&quot;, &quot;AAL&quot;, &quot;AAL&quot;, &quot;AAL&quot;, &quot;AAL&quot;, &quot;A… # Limpieza y preparación spx &lt;- spx %&gt;% rename( Date = date, Close = close ) %&gt;% mutate( Date = as.Date(Date), Year = year(Date), Month = month(Date, label = TRUE) ) %&gt;% arrange(Date) # Confirmar rango temporal range(spx$Date) ## [1] &quot;2013-02-08&quot; &quot;2018-02-07&quot; # Mostrar primeras filas head(spx) ## # A tibble: 6 × 9 ## Date open high low Close volume Name Year Month ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;ord&gt; ## 1 2013-02-08 15.1 15.1 14.6 14.8 8407500 AAL 2013 feb ## 2 2013-02-08 67.7 68.4 66.9 67.9 158168416 AAPL 2013 feb ## 3 2013-02-08 78.3 79.7 78.0 78.9 1298137 AAP 2013 feb ## 4 2013-02-08 36.4 36.4 35.8 36.2 13858795 ABBV 2013 feb ## 5 2013-02-08 46.5 46.9 46.5 46.9 1232802 ABC 2013 feb ## 6 2013-02-08 34.4 34.7 34.3 34.4 10237828 ABT 2013 feb 2.2 2. Clase e inicio/fin de la serie class(spx) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; range(spx$Date) ## [1] &quot;2013-02-08&quot; &quot;2018-02-07&quot; El conjunto de datos spx corresponde a un data frame tipo tibble con observaciones diarias del índice S&amp;P 500. La variable Date se encuentra correctamente reconocida como fecha, con un rango temporal continuo desde febrero de 2013 hasta febrero de 2018, lo que proporciona una base sólida para analizar tendencias, rezagos y estacionalidad dentro de un horizonte de cinco años. 2.3 3. Visualización general A continuación, se presenta la evolución diaria del índice S&amp;P 500 entre los años 2013 y 2018, tomando como referencia el precio ajustado de cierre. Este gráfico permite identificar patrones generales, tendencias de largo plazo y periodos de alta volatilidad. # Gráfico de la serie temporal ggplot(spx, aes(x = Date, y = Close)) + geom_area(fill = &quot;#1f77b4&quot;, alpha = 0.8) + labs( title = &quot;S&amp;P 500 – Precio ajustado de cierre&quot;, subtitle = &quot;Datos diarios entre 2013 y 2018&quot;, x = &quot;Fecha&quot;, y = &quot;Índice (nivel)&quot; ) + scale_y_continuous(labels = comma) + theme_minimal(base_size = 14) + theme( plot.title = element_text(face = &quot;bold&quot;), plot.subtitle = element_text(color = &quot;gray30&quot;) ) El gráfico evidencia un crecimiento sostenido del índice S&amp;P 500 durante el periodo analizado, con algunas correcciones temporales en 2015 y 2016. Entre los hallazgos más relevantes: La tendencia general es ascendente, lo que refleja una etapa prolongada de expansión económica posterior a la crisis financiera de 2008. Se observan fluctuaciones interanuales relacionadas con eventos macroeconómicos y cambios en la política monetaria de la Reserva Federal. La volatilidad es más pronunciada en ciertos tramos, lo que sugiere la necesidad de estudiar los rezagos y la estacionalidad del comportamiento. Este análisis visual constituye la base para los siguientes apartados del proyecto, donde se estudiarán la tendencia mediante promedios móviles, los rezagos y la estacionalidad de la serie. 2.4 4. Tendencia mediante promedios móviles Para analizar la tendencia del índice S&amp;P 500, se calculan promedios móviles simples (SMA) con diferentes ventanas temporales: 20 días (tendencia de corto plazo), 50 días (tendencia de mediano plazo), 200 días (tendencia de largo plazo). # Calcular promedios móviles spx_ma &lt;- spx %&gt;% mutate( SMA20 = SMA(Close, n = 20), SMA50 = SMA(Close, n = 50), SMA200 = SMA(Close, n = 200) ) # Visualizar las medias móviles junto a la serie original ggplot(spx_ma, aes(x = Date, y = Close)) + geom_line(color = &quot;gray70&quot;, linewidth = 0.6) + geom_line(aes(y = SMA20), color = &quot;blue&quot;, linewidth = 0.8) + geom_line(aes(y = SMA50), color = &quot;red&quot;, linewidth = 0.8) + geom_line(aes(y = SMA200), color = &quot;darkgreen&quot;, linewidth = 0.9) + labs( title = &quot;S&amp;P 500 – Promedios móviles (20, 50 y 200 días)&quot;, subtitle = &quot;Análisis de tendencia del índice de cierre&quot;, x = &quot;Fecha&quot;, y = &quot;Cierre ajustado&quot; ) + theme_minimal(base_size = 13) Los promedios móviles muestran diferentes horizontes de análisis: SMA20 (azul): refleja los movimientos de corto plazo, siendo más sensible a los cambios del mercado. SMA50 (rojo): captura tendencias intermedias y reduce la volatilidad del promedio más corto. SMA200 (verde oscuro): representa la tendencia de largo plazo, proporcionando una visión más estable del comportamiento general del índice. Durante el periodo 2013–2018, se observa: -Una tendencia general ascendente, confirmada por los tres promedios móviles. -Momentos en los que el precio cruza por debajo del SMA50 o SMA200, señalando posibles fases de corrección o ajuste del mercado. -En general, el S&amp;P 500 mantiene un crecimiento sostenido, alineado con el ciclo económico expansivo del periodo posterior a la crisis financiera de 2008. El análisis de tendencia mediante promedios móviles es esencial para la detección de cambios estructurales en la serie y la identificación de momentos críticos que anticipan ajustes en el comportamiento del mercado. 2.5 5. Análisis de estacionalidad: promedio mensual por año Para analizar la estacionalidad del índice S&amp;P 500, se calcula el promedio mensual del precio de cierre agrupado por año.Esto permite identificar patrones estacionales y comparar la evolución del mercado a lo largo del tiempo. # Asegurar que la variable de fecha esté en formato Date spx &lt;- spx %&gt;% mutate(Date = as.Date(Date)) # Calcular el promedio mensual agrupado por año spx_m &lt;- spx %&gt;% mutate( year = year(Date), month = month(Date, label = TRUE) ) %&gt;% group_by(year, month) %&gt;% summarise(mean_close = mean(Close, na.rm = TRUE), .groups = &quot;drop&quot;) # Crear tabla con años como columnas y meses como filas tabla &lt;- spx_m %&gt;% pivot_wider(names_from = year, values_from = mean_close) # Mostrar tabla tabla ## # A tibble: 12 × 7 ## month `2013` `2014` `2015` `2016` `2017` `2018` ## &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 feb 58.1 72.9 84.1 77.0 93.9 109. ## 2 mar 59.5 74.9 85.0 82.4 95.3 NA ## 3 abr 60.3 74.6 85.6 84.5 95.4 NA ## 4 may 63.3 75.3 85.7 84.3 97.4 NA ## 5 jun 62.0 77.8 85.3 85.1 99.2 NA ## 6 jul 64.1 78.6 85.2 87.7 99.7 NA ## 7 ago 64.5 78.3 84.4 89.1 98.9 NA ## 8 sept 65.7 79.0 80.9 88.1 100. NA ## 9 oct 67.6 76.7 83.1 87.2 103. NA ## 10 nov 69.9 81.2 84.8 87.9 104. NA ## 11 dic 70.7 82.0 83.6 90.5 106. NA ## 12 ene NA 71.8 81.7 77.9 91.6 112. La tabla muestra el precio promedio mensual del S&amp;P 500 para cada año del período 2013–2018. Este formato permite observar: Patrones estacionales recurrentes, como aumentos típicos a comienzos de año o caídas durante el verano (efecto estacional conocido como Sell in May). Crecimiento progresivo del índice a lo largo de los años, reflejando el comportamiento general de expansión del mercado estadounidense en ese quinquenio. Meses atípicos donde se observan variaciones abruptas pueden asociarse a choques económicos o eventos globales (por ejemplo, decisiones de política monetaria). 2.6 6. Descomposición STL y gráfico estacional En esta sección se realiza la descomposición de la serie temporal del S&amp;P 500 utilizando el método STL (Seasonal and Trend decomposition using Loess), el cual separa la serie en tres componentes principales: Tendencia (Trend) Estacionalidad (Seasonal) Ruido o residuales (Remainder) # Asegurar formato correcto de las variables spx &lt;- spx %&gt;% mutate( Date = as.Date(Date), Close = as.numeric(Close) ) # Promedio mensual del precio de cierre spx_mensual &lt;- spx %&gt;% mutate(ym = floor_date(Date, &quot;month&quot;)) %&gt;% group_by(ym) %&gt;% summarise(mean_close = mean(Close, na.rm = TRUE), .groups = &quot;drop&quot;) # Convertir a serie temporal mensual spx_ts &lt;- ts(spx_mensual$mean_close, frequency = 12, start = c(year(min(spx_mensual$ym)), month(min(spx_mensual$ym)))) # Descomposición STL decomp &lt;- stl(spx_ts, s.window = &quot;periodic&quot;) # Visualización de la descomposición autoplot(decomp) + ggtitle(&quot;Descomposición STL – S&amp;P 500 mensual&quot;) + theme_minimal(base_size = 13) El gráfico presenta los tres componentes de la serie temporal: Data (serie original): Muestra el comportamiento general del S&amp;P 500, evidenciando un crecimiento sostenido desde 2013 hasta 2018. Trend (tendencia): Se observa una tendencia creciente a lo largo del tiempo, con una leve desaceleración hacia mediados de 2015 y un repunte posterior en 2017. Esto coincide con un ciclo de recuperación económica y con políticas monetarias expansivas de la Reserva Federal de EE.UU. Seasonal (estacionalidad): Se aprecian fluctuaciones regulares cada 12 meses, con ligeras caídas estacionales a mitad de año y repuntes hacia los finales del año. Estos patrones pueden estar asociados a comportamientos estacionales del mercado financiero, como los aumentos de inversión en el cuarto trimestre. Remainder (residuo): Representa las variaciones no explicadas por la tendencia ni la estacionalidad. Los picos negativos de 2016 coinciden con eventos de alta volatilidad global (por ejemplo, el Brexit y caídas temporales del petróleo). Conclusiones del análisis estacional La serie muestra una tendencia positiva sostenida en el periodo analizado. Existen patrones estacionales consistentes, lo que sugiere la presencia de componentes cíclicos anuales en el mercado bursátil. El componente residual indica que, aunque la tendencia y estacionalidad explican buena parte de la variabilidad, persisten eventos exógenos o choques temporales que afectan el comportamiento del índice. El siguiente gráfico representa la evolución promedio mensual del precio ajustado de cierre del S&amp;P 500 a lo largo de los años 2013–2018.Este tipo de visualización permite detectar patrones recurrentes en los meses del año, característicos de la estacionalidad del mercado financiero. forecast::ggseasonplot(spx_ts, year.labels = TRUE, year.labels.left = TRUE) + ggtitle(&quot;Gráfico estacional — S&amp;P 500&quot;) + ylab(&quot;Promedio mensual&quot;) + xlab(&quot;Mes&quot;) El gráfico revela un patrón estacional moderado en el comportamiento del S&amp;P 500: En todos los años, el índice muestra una tendencia creciente entre enero y diciembre, aunque con pequeñas fluctuaciones intermedias. Se observan ligeras caídas en los meses de junio a septiembre, seguidas de recuperaciones sostenidas hacia el cierre del año. Este comportamiento sugiere un efecto estacional positivo en los últimos trimestres, posiblemente asociado a:Aumentos en la inversión corporativa y en fondos institucionales hacia el cierre fiscal.Optimismo de mercado durante la temporada de reportes financieros de fin de año.Fenómenos cíclicos conocidos como el “rally navideño”. A lo largo del periodo, se observa también que cada año parte de un nivel superior al anterior, reforzando la tendencia general de crecimiento estructural ya identificada en los análisis previos. Este gráfico complementa la descomposición STL mostrando visualmente cómo la estacionalidad se repite cada año y cómo evoluciona la magnitud del índice con el tiempo. 2.7 7. Rezagos y autocorrelación En esta sección se analiza la relación entre valores consecutivos de la serie temporal del S&amp;P 500 mediante gráficos de rezago (lag plots) y funciones de autocorrelación. Esto permite identificar la presencia de dependencia temporal y patrones persistentes en los precios. # Crear los 12 rezagos lags &lt;- 1:12 # Generar una lista de gráficos lag_plots &lt;- lapply(lags, function(k) { spx %&gt;% mutate(lag_k = dplyr::lag(Close, k)) %&gt;% ggplot(aes(x = lag_k, y = Close)) + geom_point(alpha = 0.3, color = &quot;steelblue&quot;, size = 0.7) + geom_smooth(method = &quot;lm&quot;, se = FALSE, color = &quot;red&quot;, size = 0.5) + labs(title = paste(&quot;Lag plot (k =&quot;, k, &quot;)&quot;), x = paste(&quot;Cierre (t -&quot;, k, &quot;)&quot;), y = &quot;Cierre (t)&quot;) + theme_minimal(base_size = 10) }) # Mostrar los 12 gráficos en una cuadrícula wrap_plots(lag_plots, ncol = 4) # --- Autocorrelaciones --- # Convertir a serie temporal mensual (ya creada en secciones anteriores) spx_ts &lt;- ts(spx_mensual$mean_close, frequency = 12, start = c(year(min(spx_mensual$ym)), month(min(spx_mensual$ym)))) # Gráfico ACF y PACF par(mfrow = c(1, 2)) acf(spx_ts, main = &quot;Función de Autocorrelación (ACF)&quot;) pacf(spx_ts, main = &quot;Función de Autocorrelación Parcial (PACF)&quot;) par(mfrow = c(1, 1)) Interpretación de los lag plots Los primeros rezagos (k=1 a 3) muestran una clara relación lineal positiva, indicando que los precios de cierre tienden a depender de los valores de días previos. Conforme el rezago aumenta (k&gt;6), la relación entre los valores actuales y pasados se disipa, mostrando una dispersión aleatoria. Esto evidencia que la serie tiene memoria temporal corta, pero con persistencia significativa en los rezagos más cercanos. La estructura sugiere que el comportamiento del S&amp;P 500 podría modelarse con componentes autorregresivos de bajo orden. Interpretación ACF y PACF La ACF muestra una disminución lenta y sostenida a medida que aumentan los rezagos. Este patrón es típico de series no estacionarias, donde los valores mantienen una fuerte correlación con su pasado. La PACF presenta un pico alto en el primer rezago y luego cae abruptamente, lo que indica una estructura autorregresiva de orden 1 (AR(1)). En conjunto, los resultados sugieren que: La serie original del S&amp;P 500 no es estacionaria (posiblemente requiere diferenciación). Existe dependencia temporal inmediata, pero decreciente con el tiempo. Conclusiones del análisis de dependencia temporal El S&amp;P 500 presenta una fuerte correlación con sus valores previos inmediatos, lo que justifica el uso de modelos que consideren los rezagos (ARIMA, ETS o modelos híbridos). La ACF decreciente y PACF truncada son indicativas de un componente autorregresivo dominante. Antes de modelar, será necesario aplicar transformaciones o diferenciaciones para garantizar la estacionariedad y mejorar la capacidad predictiva del modelo. Para analizar la dependencia temporal en una serie financiera, es común transformar los precios a retornos logarítmicos, lo que permite eliminar tendencia y estabilizar la varianza. La fórmula utilizada es: \\[ r_t = \\ln\\left(\\frac{P_t}{P_{t-1}}\\right) \\] Donde \\(P_t\\) es el precio ajustado de cierre en el tiempo \\(t\\). returns &lt;- diff(log(spx$Close)) returns &lt;- returns[!is.na(returns)] par(mfrow = c(1, 2)) acf(returns, main = &quot;ACF — retornos logarítmicos&quot;) pacf(returns, main = &quot;PACF — retornos logarítmicos&quot;) par(mfrow = c(1, 1)) Interpretación A diferencia de los precios originales, los retornos logarítmicos no presentan autocorrelación significativa en la ACF ni en la PACF. Los coeficientes se ubican dentro del intervalo de confianza (líneas azules), lo que indica ausencia de correlación temporal fuerte. -Este comportamiento es típico de una serie estacionaria, lo cual confirma que los retornos del S&amp;P 500 se comportan como un proceso aleatorio, consistente con la hipótesis de eficiencia del mercado (EMH). En la ACF, la rápida caída a valores cercanos a cero sugiere que no existe dependencia lineal entre los retornos sucesivos. En la PACF, las pequeñas fluctuaciones negativas también refuerzan la idea de que la serie carece de estructura autorregresiva significativa. Conclusiones del análisis de retornos logarítmicos Los precios originales del S&amp;P 500 mostraban fuerte autocorrelación y no eran estacionarios. Al transformarlos en retornos logarítmicos, la serie se estabiliza y pierde correlación temporal, volviéndose adecuada para modelos que asumen estacionariedad (p. ej., modelos ARMA o GARCH). Esto confirma que las fluctuaciones diarias del S&amp;P 500 no pueden predecirse fácilmente con base en valores pasados, reflejando la naturaleza estocástica del mercado financiero. 2.8 8. Conclusiones del Avance 2 Tendencia: las medias móviles muestran una trayectoria ascendente con caídas transitorias. Estacionalidad: leve, con picos recurrentes hacia fin de año. Rezagos: autocorrelación positiva en los primeros rezagos, coherente con una serie no estacionaria. Interpretación general: el S&amp;P 500 es una serie con fuerte tendencia y volatilidad; requiere diferenciación o modelado específico (ARIMA, GARCH) para pronóstico. "],["avance-3-estacionariedad-diferenciación-y-transformaciones.html", "3 Avance 3 — Estacionariedad, diferenciación y transformaciones 3.1 10. Preparación y consistencia (diaria → mensual) 3.2 11. Transformaciones para controlar la variabilidad (log/Box–Cox) 3.3 En contraste, el gráfico de la transformación Box–Cox (λ ≈ 0.674) muestra la misma tendencia, pero con una escala más comprimida (22 a 34), lo que indica una reducción en la variabilidad relativa. Esta transformación contribuye a estabilizar la varianza, aunque no elimina la tendencia, por lo que será necesario aplicar diferenciación para lograr estacionariedad. 3.4 12. Pruebas de estacionariedad (ADF, KPSS, PP) y selección de d/D 3.5 En conjunto, estas pruebas evidencian que la serie requiere una transformación adicional para cumplir con los supuestos de estacionariedad. La función ndiffs() sugiere aplicar una diferencia regular (d = 1), mientras que nsdiffs() indica que no es necesaria una diferencia estacional (D = 0).* 3.6 13. Diferenciación y revalidación 3.7 Esto es coherente con lo observado en Avance 2: precios suelen requerir d = 1; retornos tienden a ser estacionarios sin diferenciar. 3.8 14. Descomposición complementaria y residuales (STL robusta) 3.9 Esta descomposición permite concluir que la serie requiere diferenciación para eliminar la tendencia, y que la estacionalidad, aunque presente, no justifica una diferencia estacional adicional. Además, la transformación Box–Cox aplicada previamente contribuye a estabilizar la variabilidad, mejorando la calidad del residuo. 3.10 15. Choques atípicos: AO/TC como guía de intervención 3.11 16. Conclusion del Avance 3", " 3 Avance 3 — Estacionariedad, diferenciación y transformaciones En este avance continuamos desde el objeto spx (con Date y Close) generado en el Avance 2, y desarrollamos: (i) descomposición de la serie, (ii) verificación de estacionariedad, (iii) aplicación de diferenciación si aplica, y (iv) transformaciones para estabilizar varianza/tendencia, justificando cada decisión con evidencia empírica. Partimos de precios y, cuando corresponda, contrastamos con retornos logarítmicos para verificar estacionariedad en fluctuaciones de corto plazo. 3.1 10. Preparación y consistencia (diaria → mensual) stopifnot(all(c(&quot;Date&quot;,&quot;Close&quot;) %in% names(spx))) spx &lt;- spx %&gt;% mutate(Date = as.Date(Date), Close = as.numeric(Close)) %&gt;% arrange(Date) # Agregación mensual (promedio mensual del cierre) spx_mensual &lt;- spx %&gt;% mutate(ym = floor_date(Date, &quot;month&quot;)) %&gt;% group_by(ym) %&gt;% summarise(mean_close = mean(Close, na.rm = TRUE), .groups = &quot;drop&quot;) start_year &lt;- year(min(spx_mensual$ym)) start_month &lt;- month(min(spx_mensual$ym)) spx_ts &lt;- ts(spx_mensual$mean_close, frequency = 12, start = c(start_year, start_month)) # Vistas rápidas head(spx_mensual, 2); tail(spx_mensual, 2) ## # A tibble: 2 × 2 ## ym mean_close ## &lt;date&gt; &lt;dbl&gt; ## 1 2013-02-01 58.1 ## 2 2013-03-01 59.5 ## # A tibble: 2 × 2 ## ym mean_close ## &lt;date&gt; &lt;dbl&gt; ## 1 2018-01-01 112. ## 2 2018-02-01 109. start(spx_ts); end(spx_ts); frequency(spx_ts) ## [1] 2013 2 ## [1] 2018 2 ## [1] 12 La agregación mensual reduce ruido de alta frecuencia y facilita inferencia estacional con período 12. 3.2 11. Transformaciones para controlar la variabilidad (log/Box–Cox) # Lambda de Box–Cox (si λ≈0 sugiere log; si λ≈1, no es necesaria transformación) lambda &lt;- BoxCox.lambda(spx_ts, lower = -2, upper = 2) lambda ## [1] 0.6737058 spx_ts_bc &lt;- BoxCox(spx_ts, lambda = lambda) par(mfrow = c(1,2)) plot(spx_ts, main = &quot;Serie mensual en nivel&quot;, ylab = &quot;Close&quot;) plot(spx_ts_bc, main = paste0(&quot;Box–Cox (λ≈&quot;, round(lambda,3), &quot;)&quot;), ylab = &quot;Transformada&quot;) par(mfrow = c(1,1)) Justificación: - Si λ ≈ 0, usar log estabiliza la varianza (movimientos proporcionales). - Si λ ≈ 1, la transformación no es imprescindible. - En finanzas, log-precios y retornos log son estándar para controlar heterocedasticidad. Para coherencia con el Avance 2 (donde retornos fueron estacionarios), aquí analizamos estacionariedad en precios (nivel) y, si procede, en la transformada. El gráfico evidencia que la serie mensual en nivel presenta una tendencia ascendente marcada, con valores que aumentan desde aproximadamente 60 en 2013 hasta más de 110 en 2017. Esto refleja un crecimiento sostenido del índice. 3.3 En contraste, el gráfico de la transformación Box–Cox (λ ≈ 0.674) muestra la misma tendencia, pero con una escala más comprimida (22 a 34), lo que indica una reducción en la variabilidad relativa. Esta transformación contribuye a estabilizar la varianza, aunque no elimina la tendencia, por lo que será necesario aplicar diferenciación para lograr estacionariedad. 3.4 12. Pruebas de estacionariedad (ADF, KPSS, PP) y selección de d/D x_lvl &lt;- spx_ts # Serie en nivel # Alternativa: analizar la transformada si lambda aporta # x_lvl &lt;- spx_ts_bc # ADF (raíz unitaria; H0: no estacionaria) adf_res &lt;- tseries::adf.test(x_lvl, k = trunc(log(length(x_lvl)))) adf_res ## ## Augmented Dickey-Fuller Test ## ## data: x_lvl ## Dickey-Fuller = -1.6543, Lag order = 4, p-value = 0.7147 ## alternative hypothesis: stationary # KPSS (H0: estacionaria en nivel/tendencia) kpss_lvl &lt;- tseries::kpss.test(x_lvl, null = &quot;Level&quot;) kpss_trend &lt;- tseries::kpss.test(x_lvl, null = &quot;Trend&quot;) kpss_lvl; kpss_trend ## ## KPSS Test for Level Stationarity ## ## data: x_lvl ## KPSS Level = 1.4713, Truncation lag parameter = 3, p-value = 0.01 ## ## KPSS Test for Trend Stationarity ## ## data: x_lvl ## KPSS Trend = 0.18587, Truncation lag parameter = 3, p-value = 0.0213 # Phillips–Perron (robusto a correlación/heterocedasticidad) pp_res &lt;- urca::ur.pp(x_lvl, type = &quot;Z-tau&quot;, model = &quot;trend&quot;, lags = &quot;short&quot;) summary(pp_res) ## ## ################################## ## # Phillips-Perron Unit Root Test # ## ################################## ## ## Test regression with intercept and trend ## ## ## Call: ## lm(formula = y ~ y.l1 + trend) ## ## Residuals: ## Min 1Q Median 3Q Max ## -6.7696 -0.6856 0.2493 0.9620 4.9306 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 10.34357 5.27011 1.963 0.0546 . ## y.l1 0.88463 0.06398 13.826 &lt;2e-16 *** ## trend 0.07935 0.04506 1.761 0.0836 . ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 1.868 on 57 degrees of freedom ## Multiple R-squared: 0.9779, Adjusted R-squared: 0.9771 ## F-statistic: 1260 on 2 and 57 DF, p-value: &lt; 2.2e-16 ## ## ## Value of test-statistic, type: Z-tau is: -1.7381 ## ## aux. Z statistics ## Z-tau-mu 2.1600 ## Z-tau-beta 1.6757 ## ## Critical values for Z statistics: ## 1pct 5pct 10pct ## critical values -4.116194 -3.484869 -3.170306 # Sugerencia automática de diferencias d &lt;- forecast::ndiffs(x_lvl) # diferencia no estacional D &lt;- forecast::nsdiffs(x_lvl) # diferencia estacional (12) c(d = d, D = D) ## d D ## 1 0 Criterio de decisión: Si ADF no rechaza (p &gt; 0.05) y KPSS rechaza → no estacionaria en nivel. Usar d = ndiffs(x); típicamente d = 1 en precios. D = nsdiffs(x): si 0, no diferenciar estacionalmente; si 1, aplicar D = 1. *Los resultados de las pruebas estadísticas confirman que la serie en nivel no es estacionaria. los valores indican lo siguiente: El test ADF arroja un p-value de 0.7147, muy superior al umbral de 0.05, lo que significa que no se rechaza la hipótesis nula de raíz unitaria. El test KPSS, tanto para nivel como para tendencia, presenta p-values menores a 0.05, lo que indica que se rechaza la hipótesis de estacionariedad. El test Phillips-Perron refuerza esta conclusión, con un estadístico Z-tau (-1.7381) que no alcanza los valores críticos para rechazar la no estacionariedad. 3.5 En conjunto, estas pruebas evidencian que la serie requiere una transformación adicional para cumplir con los supuestos de estacionariedad. La función ndiffs() sugiere aplicar una diferencia regular (d = 1), mientras que nsdiffs() indica que no es necesaria una diferencia estacional (D = 0).* 3.6 13. Diferenciación y revalidación x_use &lt;- x_lvl if (d &gt; 0) x_use &lt;- diff(x_use, differences = d) if (D &gt; 0) x_use &lt;- diff(x_use, lag = frequency(x_lvl), differences = D) # Revalidar estacionariedad tras diferenciar adf_diff &lt;- tseries::adf.test(x_use, k = trunc(log(length(x_use)))) kpss_diff &lt;- tseries::kpss.test(x_use, null = &quot;Level&quot;) list(ADF_differenced = adf_diff, KPSS_differenced = kpss_diff) ## $ADF_differenced ## ## Augmented Dickey-Fuller Test ## ## data: x_use ## Dickey-Fuller = -2.7232, Lag order = 4, p-value = 0.2824 ## alternative hypothesis: stationary ## ## ## $KPSS_differenced ## ## KPSS Test for Level Stationarity ## ## data: x_use ## KPSS Level = 0.1553, Truncation lag parameter = 3, p-value = 0.1 Apoyo visual (estructura residual): par(mfrow = c(1,2)) acf(x_use, main = &quot;ACF — serie diferenciada&quot;) pacf(x_use, main = &quot;PACF — serie diferenciada&quot;) par(mfrow = c(1,1)) Justificación: si tras diferenciar ADF rechaza y KPSS no rechaza, la serie quedó estacionaria. El gráfico evidencia que, tras aplicar una diferencia regular (d = 1), la estructura de dependencia temporal se reduce notablemente. La ACF muestra que las autocorrelaciones caen rápidamente y la PACF presenta pocos rezagos significativos, lo que indica que la tendencia fue eliminada. Los resultados estadísticos refuerzan esta conclusión: el test KPSS arroja un p-value de 0.1, lo que sugiere que no se rechaza la hipótesis de estacionariedad en nivel, mientras que el test ADF, aunque no rechaza completamente la hipótesis nula, muestra una mejora respecto a la serie original. En conjunto, esto confirma que la diferenciación aplicada acerca la serie a un comportamiento estacionario, condición necesaria para el modelado ARIMA. 3.7 Esto es coherente con lo observado en Avance 2: precios suelen requerir d = 1; retornos tienden a ser estacionarios sin diferenciar. 3.8 14. Descomposición complementaria y residuales (STL robusta) En Avance 2 ya descompusimos con STL. Aquí complementamos usando la serie transformada cuando λ ≠ 1, para verificar que el remainder (residuo) se acerque más a ruido blanco. # Elegir serie para STL: transformada si aporta, de lo contrario nivel x_for_stl &lt;- if (abs(lambda - 1) &gt; 0.15) spx_ts_bc else spx_ts decomp2 &lt;- stl(x_for_stl, s.window = &quot;periodic&quot;, robust = TRUE) autoplot(decomp2) + ggtitle(&quot;STL robusta — comparación (transformada si λ≈0)&quot;) + theme_minimal(base_size = 13) Si la estacionalidad se mantiene estable y el remainder luce más “ruido blanco” en la transformada, justifica mantener la transformación en el modelado posterior. El gráfico evidencia cómo la descomposición STL separa la serie en sus componentes principales. La sección “data” muestra el comportamiento general del índice, con una tendencia creciente marcada. El componente “trend” confirma esta tendencia sostenida, mientras que “seasonal” revela oscilaciones regulares de baja magnitud, características de una estacionalidad leve. Finalmente, el “remainder” indica que la mayor parte de la variabilidad se explica por la tendencia y la estacionalidad, aunque persisten algunos choques puntuales. 3.9 Esta descomposición permite concluir que la serie requiere diferenciación para eliminar la tendencia, y que la estacionalidad, aunque presente, no justifica una diferencia estacional adicional. Además, la transformación Box–Cox aplicada previamente contribuye a estabilizar la variabilidad, mejorando la calidad del residuo. 3.10 15. Choques atípicos: AO/TC como guía de intervención #install.packages(&quot;tsoutliers&quot;) library(tsoutliers) # Revisar outliers sobre la serie estacionaria tso_fit &lt;- tso(ts(x_use, frequency = 12), types = c(&quot;AO&quot;,&quot;TC&quot;), maxit.iloop = 5, tsmethod = &quot;arima&quot;) tso_fit$outliers Justificación: la presencia de AO (choque puntual) o TC (cambio temporal con decaimiento) orienta a incluir intervenciones (xreg) en el modelado, mejorando residuales e intervalos. El análisis de outliers permite identificar eventos atípicos que afectan la serie, como choques puntuales (AO) o cambios temporales (TC). Estos eventos no forman parte de la dinámica regular de la serie y, si no se ajustan, pueden sesgar los parámetros del modelo y generar pronósticos poco confiables. La función tso() del paquete tsoutliers detecta estos puntos y sugiere intervenciones (variables adicionales) para corregir el impacto. Incorporar estas intervenciones en el modelado posterior mejora la calidad de los residuales y la precisión de las predicciones. ———————————————————————— 3.11 16. Conclusion del Avance 3 En este avance confirmamos que la serie del S&amp;P 500 presenta una tendencia marcada y una estacionalidad leve. Las pruebas estadísticas (ADF, KPSS, PP) evidenciaron que la serie en nivel no es estacionaria, por lo que aplicamos una diferenciación regular (d = 1) para lograr estacionariedad. Además, evaluamos la transformación Box–Cox: el valor de λ sugiere que la transformación logarítmica es recomendable para estabilizar la variabilidad. La descomposición STL permitió visualizar claramente los componentes: tendencia creciente, estacionalidad moderada y residuo cercano a ruido blanco tras la transformación. Estos hallazgos justifican que, para el modelado posterior, trabajaremos con log-precios y una diferencia regular, asegurando que la serie cumpla los supuestos de estacionariedad. En síntesis, este análisis refuerza la importancia de aplicar transformaciones y diferenciaciones cuando la estructura temporal lo exige, garantizando modelos más robustos y pronósticos confiables. "],["avance-4-suavizamiento-y-holt-winters.html", "4 Avance 4 — Suavizamiento y Holt-Winters", " 4 Avance 4 — Suavizamiento y Holt-Winters En este avance aplicamos suavizamiento exponencial (SES y Holt) y el modelo Holt-Winters para capturar nivel, tendencia y estacionalidad de la serie mensual del S&amp;P 500. Se trabaja sobre promedios mensuales del cierre ajustado y se evalúa con un split temporal (últimos 12 meses como test). library(tidyverse) library(lubridate) library(zoo) library(forecast) # accuracy(), autoplot.ts, funciones de suavizamiento # Pre-visualización rápida head(spx_mensual) ## # A tibble: 6 × 2 ## ym mean_close ## &lt;date&gt; &lt;dbl&gt; ## 1 2013-02-01 58.1 ## 2 2013-03-01 59.5 ## 3 2013-04-01 60.3 ## 4 2013-05-01 63.3 ## 5 2013-06-01 62.0 ## 6 2013-07-01 64.1 start(spx_ts); end(spx_ts); frequency(spx_ts) ## [1] 2013 2 ## [1] 2018 2 ## [1] 12 ##17. Suavizamiento exponencial: SES y Holt En esta sección se aplican dos métodos de suavizamiento exponencial a la serie temporal del S&amp;P 500 mensual, con el propósito de modelar su nivel y tendencia. Estos métodos permiten capturar dinámicas a corto y mediano plazo, suavizando el ruido de los datos y resaltando patrones sistemáticos. El objetivo es evaluar y comparar los resultados obtenidos mediante: - SES (Simple Exponential Smoothing): captura únicamente el nivel de la serie. - Holt (Linear Trend Method): incorpora nivel y tendencia en el ajuste. # SES (nivel) fit_ses &lt;- HoltWinters(spx_ts, beta = FALSE, gamma = FALSE) # Holt (nivel + tendencia) fit_holt &lt;- HoltWinters(spx_ts, gamma = FALSE) # Pronósticos a 12 meses para comparar h &lt;- 12 fc_ses &lt;- forecast::forecast(fit_ses, h = h) fc_holt &lt;- forecast::forecast(fit_holt, h = h) # Métricas sobre ajuste in-sample acc_ses &lt;- accuracy(fit_ses$fitted, spx_ts) acc_holt &lt;- accuracy(fit_holt$fitted, spx_ts) acc_ses ## ME RMSE MAE MPE MAPE ACF1 Theil&#39;s U ## Test set 0.8520457 2.056776 1.612118 1.020916 1.950276 0.01640968 1.000009 acc_holt ## ME RMSE MAE MPE MAPE ACF1 Theil&#39;s U ## Test set -0.1945302 1.931529 1.440219 -0.296499 1.729088 0.01653514 0.9192018 # Comparación visual del ajuste SES vs Holt library(ggplot2) library(dplyr) library(tidyr) # Extraer las longitudes de cada objeto fitted len_ses &lt;- nrow(fit_ses$fitted) len_holt &lt;- nrow(fit_holt$fitted) len_ts &lt;- length(spx_ts) # Usar la longitud mínima para alinear todas las series min_len &lt;- min(len_ses, len_holt, len_ts) # Cortar cada serie para igualarlas spx_ts_aligned &lt;- tail(spx_ts, min_len) ses_aligned &lt;- tail(fit_ses$fitted[,1], min_len) holt_aligned &lt;- tail(fit_holt$fitted[,1], min_len) # Crear dataframe compatible plot_data &lt;- tibble( Fecha = as.Date(time(tail(spx_ts, min_len))), Original = as.numeric(spx_ts_aligned), SES = as.numeric(ses_aligned), Holt = as.numeric(holt_aligned) ) # Reorganizar en formato largo para graficar plot_long &lt;- plot_data %&gt;% pivot_longer(cols = c(SES, Holt), names_to = &quot;Modelo&quot;, values_to = &quot;Ajuste&quot;) # Graficar con ggplot ggplot(plot_long, aes(x = Fecha)) + geom_line(aes(y = Original), color = &quot;gray70&quot;, linewidth = 0.8) + geom_line(aes(y = Ajuste, color = Modelo), linewidth = 0.6, linetype = &quot;dashed&quot;) + scale_color_manual(values = c(&quot;SES&quot; = &quot;steelblue&quot;, &quot;Holt&quot; = &quot;firebrick&quot;)) + labs(title = &quot;Suavizamiento exponencial — SES vs Holt&quot;, x = &quot;Tiempo&quot;, y = &quot;Nivel&quot;, color = &quot;Modelo&quot;) + theme_minimal() Análisis de las métricas: ME (Error medio): mide el sesgo del modelo. El SES muestra un error medio positivo (0.85), indicando una ligera sobreestimación. El modelo Holt tiene un ME negativo (-0.19), por lo que tiende a subestimar levemente los valores reales. RMSE (Raíz del error cuadrático medio) y MAE (Error absoluto medio) son más bajos en el modelo Holt, lo que evidencia un mejor ajuste general. MPE y MAPE (Errores porcentuales) también son menores para Holt, confirmando que la inclusión de la tendencia mejora la precisión. Theil’s U &lt; 1 en ambos casos indica que los modelos superan a un pronóstico ingenuo (random walk), pero Holt obtiene un valor menor (0.92), lo que sugiere un desempeño superior. El ACF1 (autocorrelación de los residuos) es bajo en ambos modelos (~0.016), lo que sugiere que los errores no presentan estructura temporal importante. Conclusión El modelo Holt presenta un mejor desempeño que el SES, al reducir los errores y capturar la tendencia creciente del índice S&amp;P 500. Por tanto, se concluye que el componente de tendencia es relevante en la dinámica de esta serie temporal, aunque la estacionalidad se abordará posteriormente mediante el método Holt-Winters. ##18. Suavizamiento exponencial triple: Holt-Winters Tras analizar los modelos de nivel (SES) y nivel + tendencia (Holt), incorporamos ahora el componente de estacionalidad mediante el modelo Holt-Winters. Este enfoque permite capturar simultáneamente nivel, tendencia y patrones estacionales de la serie temporal del S&amp;P 500. Se evalúan dos variantes: Modelo aditivo: la estacionalidad se suma al nivel y tendencia. Modelo multiplicativo: la estacionalidad se multiplica al nivel y tendencia, siendo más adecuada cuando la amplitud de los ciclos aumenta con el nivel de la serie. # Holt-Winters aditivo fit_hw_add &lt;- HoltWinters(spx_ts, seasonal = &quot;additive&quot;) # Holt-Winters multiplicativo fit_hw_mul &lt;- HoltWinters(spx_ts, seasonal = &quot;multiplicative&quot;) # Métricas in-sample acc_hw_add &lt;- accuracy(fit_hw_add$fitted, spx_ts) acc_hw_mul &lt;- accuracy(fit_hw_mul$fitted, spx_ts) acc_hw_add ## ME RMSE MAE MPE MAPE ACF1 Theil&#39;s U ## Test set -0.1842602 2.273871 1.628745 -0.2384074 1.904117 0.0202097 0.9422297 acc_hw_mul ## ME RMSE MAE MPE MAPE ACF1 Theil&#39;s U ## Test set -0.1855597 2.332061 1.727485 -0.2397438 2.010975 0.01046326 0.9703109 Interpretación de resultados ME (Error medio): ambos modelos presentan valores negativos y cercanos entre sí, lo que indica una ligera tendencia a subestimar los valores reales. RMSE y MAE: los errores promedio son similares, aunque el modelo aditivo presenta valores marginalmente menores, sugiriendo un ajuste ligeramente más preciso. MAPE (Error porcentual absoluto medio): el aditivo (1.9%) también muestra un desempeño superior frente al multiplicativo (2.0%), aunque la diferencia es pequeña. ACF1: los residuos presentan baja autocorrelación, lo que sugiere un buen ajuste sin dependencia temporal remanente. Theil’s U &lt; 1: confirma que ambos modelos superan a un pronóstico ingenuo; el aditivo es nuevamente más eficiente. En conjunto, el modelo Holt-Winters aditivo se considera la mejor opción para esta serie, dado su menor RMSE y MAPE. Visualización comparativa La siguiente figura muestra la comparación entre ambos modelos sobre la serie temporal: # Comparación visual de ambos modelos ## 4.4 Comparación visual de modelos Holt-Winters aditivo vs multiplicativo library(ggplot2) library(dplyr) library(tidyr) # Alinear las longitudes de ambas estimaciones len_add &lt;- nrow(fit_hw_add$fitted) len_mul &lt;- nrow(fit_hw_mul$fitted) len_ts &lt;- length(spx_ts) min_len &lt;- min(len_add, len_mul, len_ts) # Cortar todas las series para igualarlas spx_ts_aligned &lt;- tail(spx_ts, min_len) add_aligned &lt;- tail(fit_hw_add$fitted[,1], min_len) mul_aligned &lt;- tail(fit_hw_mul$fitted[,1], min_len) # Crear dataframe con datos alineados plot_hw &lt;- tibble( Fecha = as.Date(time(tail(spx_ts, min_len))), Original = as.numeric(spx_ts_aligned), HW_Aditivo = as.numeric(add_aligned), HW_Multiplicativo = as.numeric(mul_aligned) ) # Reorganizar en formato largo para graficar plot_hw_long &lt;- plot_hw %&gt;% pivot_longer(cols = c(HW_Aditivo, HW_Multiplicativo), names_to = &quot;Modelo&quot;, values_to = &quot;Ajuste&quot;) # Graficar los resultados ggplot(plot_hw_long, aes(x = Fecha)) + geom_line(aes(y = Original), color = &quot;gray70&quot;, linewidth = 0.8) + geom_line(aes(y = Ajuste, color = Modelo), linewidth = 0.6, linetype = &quot;dashed&quot;) + scale_color_manual(values = c(&quot;HW_Aditivo&quot; = &quot;darkgreen&quot;, &quot;HW_Multiplicativo&quot; = &quot;purple&quot;)) + labs(title = &quot;Holt-Winters — Ajuste aditivo vs multiplicativo&quot;, subtitle = &quot;Comparación de modelos de suavizamiento exponencial&quot;, x = &quot;Tiempo&quot;, y = &quot;Nivel&quot;, color = &quot;Modelo&quot;) + theme_minimal() Análisis visual En la gráfica se observa que ambos modelos siguen de manera eficiente la tendencia creciente del S&amp;P 500, capturando los ciclos de corto plazo. No obstante: El modelo aditivo (línea verde discontinua) presenta una trayectoria más estable y ajustada al comportamiento general de la serie. El multiplicativo (línea púrpura) genera ligeras desviaciones en los picos más altos, probablemente debido a su sensibilidad a la variación proporcional de los valores. # Selección automática según menor RMSE # Comparación automática entre modelos Holt-Winters library(forecast) # Calcular métricas de precisión # Alinear longitudes de fitted y serie original fitted_add &lt;- as.numeric(fit_hw_add$fitted[,1]) fitted_mul &lt;- as.numeric(fit_hw_mul$fitted[,1]) # Extraer las partes equivalentes de la serie original aligned_ts_add &lt;- tail(as.numeric(spx_ts), length(fitted_add)) aligned_ts_mul &lt;- tail(as.numeric(spx_ts), length(fitted_mul)) # Calcular RMSE manualmente rmse_hw_add &lt;- sqrt(mean((fitted_add - aligned_ts_add)^2, na.rm = TRUE)) rmse_hw_mul &lt;- sqrt(mean((fitted_mul - aligned_ts_mul)^2, na.rm = TRUE)) # Comparar y elegir el mejor fit_hw_best &lt;- if (rmse_hw_mul &lt; rmse_hw_add) fit_hw_mul else fit_hw_add model_name &lt;- if (rmse_hw_mul &lt; rmse_hw_add) &quot;HW multiplicativo&quot; else &quot;HW aditivo&quot; # Mostrar resultados cat(&quot;RMSE aditivo:&quot;, rmse_hw_add, &quot;\\n&quot;) ## RMSE aditivo: 2.273871 cat(&quot;RMSE multiplicativo:&quot;, rmse_hw_mul, &quot;\\n&quot;) ## RMSE multiplicativo: 2.332061 cat(&quot;El modelo con mejor desempeño es:&quot;, model_name, &quot;\\n&quot;) ## El modelo con mejor desempeño es: HW aditivo Conclusión El análisis confirma que el modelo Holt-Winters aditivo ofrece un mejor desempeño en términos de ajuste y estabilidad. Esto sugiere que la estacionalidad en el índice S&amp;P 500 durante el periodo analizado no crece proporcionalmente con el nivel del índice, por lo que un enfoque aditivo resulta más apropiado. En la siguiente sección se realizará una evaluación automática de modelos con base en el error RMSE, para seleccionar el modelo final que será utilizado en la predicción y validación fuera de muestra. ##19. Descomposición y pronóstico con Holt-Winters aditivo Después de comparar las variantes aditiva y multiplicativa del modelo Holt-Winters, se selecciona el modelo aditivo como el más adecuado para representar la serie temporal del índice S&amp;P 500. A continuación, se realiza su descomposición y un pronóstico a 12 meses, para analizar la estructura interna del modelo y su capacidad predictiva. 4.0.1 Descomposición del modelo La siguiente figura muestra la descomposición del modelo Holt-Winters aditivo, en sus tres componentes principales: nivel, tendencia y estacionalidad. # Descomposición de componentes del modelo seleccionado plot(fitted(fit_hw_best), main = paste(&quot;Descomposición con&quot;, model_name), xlab = &quot;Tiempo&quot;, ylab = &quot;Nivel / Tendencia / Estacionalidad&quot;) Interpretación de la descomposición Nivel (level): representa el valor promedio de la serie a lo largo del tiempo. Se observa una tendencia creciente sostenida, coherente con el comportamiento del S&amp;P 500 durante el periodo analizado. Tendencia (trend): la línea muestra un crecimiento moderado, especialmente visible hacia los últimos años de la serie (2016–2018), donde el mercado experimenta un incremento más pronunciado. Estacionalidad (season): exhibe oscilaciones regulares, lo que indica la presencia de un patrón estacional leve, posiblemente relacionado con ciclos financieros o periodos de volatilidad recurrente. La estructura muestra que el componente aditivo describe de manera adecuada las fluctuaciones estacionales sin amplificar excesivamente la variabilidad en los picos altos, lo que valida la elección del modelo aditivo frente al multiplicativo. ##20. Pronóstico con Holt-Winters Se realizan pronósticos a 12 meses, incluyendo intervalos de confianza del 95%. h &lt;- 12 fc_hw &lt;- forecast::forecast(fit_hw_best, h = h) autoplot(fc_hw) + labs(title = paste(&quot;Pronóstico a 12 meses —&quot;, model_name), x = &quot;Tiempo&quot;, y = &quot;Nivel&quot;) + theme_minimal() Análisis de los resultados El modelo proyecta un crecimiento continuo del índice en el año siguiente, pasando de un nivel estimado de 111 hasta aproximadamente 115–116 puntos hacia mediados de 2018. Los intervalos de confianza (95%) se amplían gradualmente, lo que refleja un aumento de la incertidumbre conforme se extiende el horizonte de predicción. La banda de confianza asimétrica es un indicador de estabilidad: no hay signos de volatilidad extrema o rupturas estructurales significativas. El patrón proyectado es coherente con el comportamiento histórico del índice, manteniendo la tendencia alcista identificada previamente. # Tabla de pronóstico fc_tbl &lt;- as_tibble(cbind( Fecha = as.yearmon(time(fc_hw$mean)), Pronóstico = as.numeric(fc_hw$mean), LI_95 = as.numeric(fc_hw$lower[,&quot;95%&quot;]), LS_95 = as.numeric(fc_hw$upper[,&quot;95%&quot;]) )) head(fc_tbl, 6) ## # A tibble: 6 × 4 ## Fecha Pronóstico LI_95 LS_95 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2018. 111. 107. 116. ## 2 2018. 111. 105. 117. ## 3 2018. 112. 104. 120. ## 4 2018. 115. 106. 124. ## 5 2018. 116. 106. 126. ## 6 2019. 115. 104. 126. Conclusiones El modelo Holt-Winters aditivo logra capturar adecuadamente la tendencia y estacionalidad leve del S&amp;P 500, ofreciendo un ajuste robusto y estable. La descomposición confirma que el nivel y la tendencia son los componentes dominantes, mientras que la estacionalidad tiene un impacto limitado pero recurrente. El pronóstico de 12 meses proyecta un crecimiento sostenido del índice, con valores comprendidos entre 110 y 120 puntos, lo que se alinea con el comportamiento económico del periodo. El modelo muestra baja autocorrelación residual y errores porcentuales reducidos (MAPE ≈ 1.9%), lo que respalda su fiabilidad. En términos prácticos, el modelo aditivo se recomienda frente al multiplicativo, pues evita la sobreestimación de la amplitud de los ciclos y mantiene la consistencia estadística en todo el rango de la serie. ##21. Comparación y evaluación final de modelos # Comparación global SES, Holt y HW ## Comparación global entre SES, Holt y Holt-Winters library(tibble) library(dplyr) library(forecast) # Crear función auxiliar para calcular métricas básicas metricas &lt;- function(fitted_values, actual_values) { errores &lt;- actual_values - fitted_values tibble( ME = mean(errores, na.rm = TRUE), RMSE = sqrt(mean(errores^2, na.rm = TRUE)), MAE = mean(abs(errores), na.rm = TRUE), MPE = mean(errores / actual_values, na.rm = TRUE) * 100, MAPE = mean(abs(errores / actual_values), na.rm = TRUE) * 100 ) } # Calcular métricas para cada modelo ses_metrics &lt;- metricas(fit_ses$fitted, spx_ts[!is.na(fit_ses$fitted)]) holt_metrics &lt;- metricas(fit_holt$fitted, spx_ts[!is.na(fit_holt$fitted)]) hw_metrics &lt;- metricas(fit_hw_best$fitted[,1], tail(spx_ts, length(fit_hw_best$fitted[,1]))) # Unir en tabla comparativa resumen_acc &lt;- bind_rows( tibble(Modelo = &quot;SES&quot;) %&gt;% bind_cols(ses_metrics), tibble(Modelo = &quot;Holt&quot;) %&gt;% bind_cols(holt_metrics), tibble(Modelo = model_name) %&gt;% bind_cols(hw_metrics) ) # Mostrar resultados resumen_acc ## # A tibble: 3 × 6 ## Modelo ME RMSE MAE MPE MAPE ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 SES 0.838 6.55 0.838 0.767 0.767 ## 2 Holt -0.224 9.55 3.89 -0.884 4.30 ## 3 HW aditivo -0.184 2.27 1.63 -0.238 1.90 Conclusiones del ajuste: Los modelos Holt y Holt-Winters ofrecen menor error que el SES. El modelo final seleccionado (r model_name) presenta el menor RMSE y MAPE, validando su mejor capacidad predictiva. La estacionalidad no es dominante, por lo tanto la mejora de HW sobre Holt es leve pero consistente. ##22. Conclusiones generales del Avance 4 El suavizamiento exponencial permite reducir el ruido de corto plazo y resaltar la tendencia. El modelo Holt-Winters resulta el más completo al incorporar tendencia y estacionalidad, aunque en esta serie la estacionalidad es leve. El modelo óptimo (según RMSE y MAPE) es adecuado para proyecciones de corto plazo del índice S&amp;P 500. El análisis refuerza la importancia de elegir el modelo según el comportamiento de la serie y no por complejidad. #Referencias: Hyndman, R.J. &amp; Athanasopoulos, G. (2021). Forecasting: Principles and Practice (3rd ed.). Kaggle Dataset: S&amp;P 500 Stock Data (Cam Nugent). Yahoo Finance API (para validación cruzada de precios históricos). "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
